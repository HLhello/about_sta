1. 

时序分析

2. 

时序分析本质上就是一种时序检查，目的是检查设计中所有的D触发器是否能够正常工作

能否正常工作就是要看在寄存器的同步端口和异步端口能否正确的采样到数据并将数据送出去

其实就是四个时间的检查

- 建立时间要求Tsetup
  - 时钟采样沿到来之前数据需要保持稳定的时间必须要大于Tsetup，否则出现时序为例
- 保持时间要求Thold
  - 时钟采样沿到来之后数据需要保持稳定的时间必须要大于Thold，否则出现时序为例
- 恢复时间要求Trecovery
  - 时钟采样沿到来之前异步复位信号保持稳定的时间必须要大于Trecovery，否则出现时序为例
- 移除时间要求Tremoval
  - 时钟采样沿到来之后异步复位信号保持稳定的时间必须要大于Tremoval，否则出现时序为例

分析上述四个时间主要是要清楚每个时间要求的捕获沿与发起沿

也就是

检查D触发器的同步端口（数据输入端口）的变化是否满足建立时间要求（setup）和保持时间要求（hold）

> 大部分是上升沿采样，在时钟跳变沿，也就是寄存器采样之前数据就需要稳定下来，如果没有稳定下来的话，输入端D的数据就很有可能不能被稳定的打入到输出端，数据段打入寄存器之后也要保持一定的时间，不能保持稳定的话可能使D端的数据不能正确的传送到Q端轻则数据出错，重则出现亚稳态的处理

检查D触发器的异步端口（异步复位端口）的变化是否满足恢复时间要求（recovery）和移除时间要求（removal）

> 异步端口的时序分析不太常见
>
> 时钟上升沿向前到recovery时间，如果复位释放的时间点在recovery时间之内，寄存器在时钟沿就不能处在一个稳定的复位状态，如果在时钟上升沿之后的removal时间段内释放了复位，时钟沿采样后可能也不会处于一个稳定的复位状态

3. 

时序分析有哪些类型

​	时序分析包括静态时序分析（STA）和动态时序分析。

动态时序分析：将布局布线生成的布线延迟信息反标注到门级网表中进行仿真，检查是否存在时序违例，此时的仿真包括门延迟和布线延迟信息，能够较好反应芯片的实际工作情况，因为不可能产生完备的测试向量，覆盖门级网表中的每一条路径，因此在动态时序分析中，无法暴露一些路径上可能存在的问题

> 仿真需要输入激励，激励覆盖时序路径不完全，就算是写了很多case也不能保证完全测试到所有时序路径；还有一个问题就是每一个case中加入了门级的延迟，所以需要的内存就很大，并且跑完一个case需要很长时间

静态时序分析：采用穷尽分析方法来提取整个电路存在的所有时序路径，计算信号在这些路径上的传播延时，检查信号的建立和保持时间是否满足时序要求，通过对最大路径延时和最小路径延时的分析，找出违背时序约束的错误。他不需要输入向量就能穷尽所有的路径，且运行速度很快，占用内存较少，不仅可以对芯片设计进行全面的时序功能检查，而且还可利用时序分析的结果来优化设计，因此静态时序分析已经越来越多的被利用到数字集成电路设计的验证中

> STA主要是通过成熟优秀的EDA工具进行的，工具把整个设计分成一小段一小段的时序路径，将每一段时序都进行上述四个时序的检查，在检测的过程中用户必须通过时序的约束告诉工具一些基本的信息，工具需要一些信息才能进行检测，静态时序分析虽然不直观，只会告诉你某条路径存在时序违例，告诉时序违例有多大，具体是怎么出现这个违例的，可能需要通过一些时序分析报告来分析数据路径时钟路径的延迟等信息来进一步确定，好处就是他会分析每一条时序路径，

4. 

时序分析工具

静态时序分析工具

动态时序分析工具

静态时序分析之前需要做什么准备工作

​	撰写基本的时序约束文件，告知时序引擎一些必要的信息（比如时钟，输入输出延时等）。若没有正确的时序约束，那么时序分析的结果是没有意义的

> 时序分析之前理清整个设计中的时钟路径和复位路径，每条时钟路径上经过哪些模块，有没有组合逻辑；复位路径上不要出现组合逻辑，比如将复位信号与其他复位信号进行与或运算，这些都是不推荐的，我们一般希望时钟路径，复位路径上是比较干净的，用户逻辑不要加在时钟路径和复位路径
>
> 需要些一些基本的约束文件，时钟信息，输入输出延时都要告知时序分析引擎，如果没有这些信息，就不能进行正确的时序分析，产生的时序分析报告也是没有意义的

5. 

D触发器中Tsetup，Thold，Tco的由来



6. 

时序分析常用的术语

源时钟

目的时钟

发起沿

捕获沿

7. 

一条普通时序路径的三要素

源时钟路径

数据路径

目的时钟路径

> 一般来说源时钟和目的时钟的起点都是相同的

8. 

FPGA常见的四种时序路径

第一种：从FPGA的输入端口到目的寄存器的数据输入端口

这种路径没有源时钟路径，用户需要越是Input Delay和时钟来告知时序引擎必要信息，时序引擎才能正确的分析这种路径

9. 

FPGA常见的四种时序路径

第二种：从源寄存器的时钟端口到目的寄存器的数据输入端口

这种时序路径是最常见的，用户需要约束源时钟和目的是时钟告知时序引擎必要的信息，时序引擎才能正确的分析这种时序路径

10.  

FPGA常见的四种时序路径

第三种：从源寄存器的时钟端口到FPGA的输出端口

这种路径没有目的时钟路径，用户需要约束Output Delay 和时钟来告知时序引擎的必要信息，时序引擎才能正确的分析这种路径

11. 

FPGA常见的四种时序路径

第四种：从FPGA的输入端口到FPGA的输出端口

这种路径中只有数据路径，用户需要约束Input Dealy 和Output Dealy，告知时序殷勤必要的信息，时序引擎才能正确的分析这种时序路径

> 很少见，重点考虑的就是上面三种路径

12. 

时序引擎是如何进行setup检查的

一般情况下目的时钟和源时钟要求是同步的才要进行setup检查，同步时钟大部分是相同频率的，如果同步时钟的频率不同有可能是通过了一个pll，或者经过了逻辑分频，频率不同还没有最小公共周期的情况时序引擎是无法完成分析的，或者说分析的结果并不可靠，一般在时序分析时需要用约束屏蔽掉

时序引擎会找出发起时钟和捕获时钟的最小公共周期，然后在最小公共周期内找到所有发起时钟和捕获时钟

首先确定建立时间要求（建立时间的捕获沿—建立时间的发起沿）

> 建立时间要求一定都是大于0 的
>
> 这里的时序分析都是以vivado为例子
>
> 这里面主要考虑三种情况
>
> 1. 目的时钟和源时钟频率相同
>    1. 建立时间分析为目的时钟向右推，遇到的第一个时钟跳变沿，不考虑延时的话是一个时钟周期
> 2. 目的时钟和源时钟频率有最小公倍数
>    1. 如果有最小公倍数，那么就是说建立时间时刻以被穷尽的，我们从这些建立时间最小的来分析，如果最小的都可以满足，那么比最小的大的当然可以满足
> 3. 目的时钟和原始没有最小公倍数
>    1. 会从当前时刻分析附近的1000个时钟周期，从中找出最小的setup时间，但这时的分析已经不可靠了，这1000个找了，下一个1000已经不确定了

13. 

时序引擎是如何进行setup检查的

时序引擎是如何进行holdup检查的

​	第一步确定建立/保持时间要求，也就是确定发起沿和捕获沿

​	第二步计算数据的需求时间

​	第三步计算数据到达时间

​	第四步计算setup的裕量（slack）

14. 

setup分析实例

data require time

data arrival time

15. 

setup分析实例

setup slack 

16.

根据公式分析哪些因素会导致setup为负

> 时钟歪斜一般来说没有在时钟路径上加一些组合逻辑或者一些其他操作的话，一般都很小
>
> Tsu，Tco的值是寄存器的特性无法改变，在使用block ram的时候，这两个个值可能比较大，这时需要仔细考虑
>
> 正常情况下需要考虑的的是setup requirement，Tlogic，Tnet，这三个会影响比较大
>
> setup requirement在同一个时钟的情况下，时序分析引擎在选择launch clock和capture clock一般情况下是正确的
>
> 有时候源时钟路径和目的时钟路径可能是不同的时钟，但是还是属于同步时钟的两个时钟，在这种情况下，capture edge 和launch edge 有可能会被选错，如果选错的情况下，setup requirement有可能会很小，这条路径在任何情况小都不可能满足时序要求了，在这种情况下，用户只能手动的设置约束调整正确
>
> 对于从同一个时钟源出来的经过pll分频器的时钟，由同一时钟源产生的，频率和相位可能不同，对于有同一个时钟源的时钟的话，他们都属于同步时钟，都可以进行时序分析
>
> logic 就是组合逻辑路径太长了，比如进行一个大位宽的乘加运算，可能就会导致组合逻辑就很长，中间就会有很多LUT
>
> Tnet布线延迟，在某些情况下，一根网线延迟是不超过1ns的，但是不排除特殊情况，比如某些模块可能会出现拥塞，如果出现拥塞，就会导致延迟很长，达到2ns，3ns都是有可能的

17. 

setup requirement 与实际情况不符合

> 比如同步同频不同相位的时钟，相位偏移很小，按照时序引擎的的分析方法，setup clock 向右推找到的第一个时钟跳变沿作为capture edge的话，就有可能导致setup requirement太小，这样就可能使得设计时序违例可能性增加

18. 

clk skew为负值，且很大

通常情况下，

- 同一个时钟下的时钟歪斜不应该超过300ps
- 同步跨时钟域电路的时钟歪斜不应该超过500ps
- 异步跨时钟域路径时钟歪斜比较大，因为时钟源不同

当时钟歪斜过大的时候

- 检查原时钟路径和目的时钟路径上是否干净

  - 是不是引入组合逻辑
  - 是不是级联了过多的BUFGCE

- 检查源时钟路径和目的时钟路径所经过的模块是否相同

  - 源时钟路径经过全局缓冲，PMMCM，目的是时钟路径只经过全局缓冲
  - 源时钟路径上级联BUFGCE-MMCM-BUFGCE，目的时钟路径上只有BUFGCE
  - 应该尽量避免源时钟路径和目的时钟路径的不同，造成延时过大，时钟歪斜过大

  

> 一般来说时钟歪斜可正可负，关注的是他很大的时候
>
> BUFGCE、MMCM、PMMCM是xlinix中的关于时钟管理的原语
>
> MMCM一般来说是有相位补偿和延时补偿，经过MMCM路径的延迟不仅没有增加，可能还会减少

19. 

Tsu/Tco很大

当设计中使用了BLOCK（dsp，RAM）的的时候，要注意

- 以block为时序路径的起点或者终点的时序路径，Tsu/Th/Tco都比普通寄存器大，布线延时和时钟歪斜也比较大
- 当使用block作为时序路径的终点的时候，时序路径的起点尽量为触发器，比如使用一个block ram ，输入前最好打一拍
- 当使用block作为时序路径的起点的时候，输出尽量设置为寄存一拍后输出，比如使用block ram构成的fifo时，尽量不要选择首字置出的模式，使用发一拍后输出可以显著降低Tco
- 当时序路径从一个block到另一个block的时候中间最好能打一拍
- 使用block的控制端口时，应该尽量保持控制信号的低扇出

> 注意使用block ram 时应该尽量降低信号的扇出，因为block ram 的位置相对比较固定，如果控制信号扇出很大，那么可能导致布线延迟比较大

20. 

工程示例

> 非首字置出的fifo，fifo的uTco非常大，在这条路径上增加别的组合逻辑的话，就有可能违例，所以block ram 的输出打一拍比较好

21. 

一般情况下，逻辑延迟和时序路径的逻辑层数息息相关

逻辑层级是指时序路径的起点和终点之间组合逻辑单元（LUT）的个数

- 逻辑层级多一级意味着多一个lut的延时加一条连接lut的网线延迟
- 通常一层逻辑的延迟是0.5ns
- 如果逻辑延迟大于0.5ns称为长路径

长路径造成时序违例修改的方法

- 修改rtl代码，在长路径的逻辑中插入流水线，将长路径打破分成多条短路径
- 使用综合工具的retiming优化方法
  - 该方法实际上是寄存器重定向
  - 原理是当某条长路径的相邻路径的建立时间裕量比较大，可以调整中间寄存器的位置，调整布线延迟，通过适当增加相邻路径的布线延迟减小长路径的布线延迟
  - 但retiming这种方法是微调，调整的幅度不大

Tlogic比较大

> 逻辑延迟一般由用户写代码造成的
>
> 通过一个lut和一根网线的延迟大概的延迟为0.5ns左右
>
> 某些情况下网线延迟很大，多一级逻辑层级会多好几个ns
>
> 如何判断某一条路径是不是逻辑层级过大的长路径呢？延迟过大呢？
>
> 时钟周期 = 0.5ns * 逻辑层级，如果时钟周期小于等于逻辑层级的延迟就说明时序路径就属于长路径了，这时候主要优化的力度就应该针对逻辑层级的延迟，时序违例大概率就是由长路径组成的

22. 

项目示例

23. 

Tnet 大

布线延迟与设计整体或者局部模块的资源利用率以及拥塞程度息息相关

正常情况下，一条网线的延迟在1ns内，在发生拥塞的时候，布线延迟会显著增加，网线的延迟达到若干ns

降低不合理的布线延迟，从解决拥塞入手

- 比如某个模块使用了大量的寄存器堆，应该考虑使用block ram踢掉
- 使用了大量的数据选择器，应考虑优化数据选择的路径数量
- 控制信号的删除很大，应该考虑间谍这些信号的扇出

> 一般来说，发生较大布线延迟的话，首先看设计整体的资源利用率是不是很大
>
> 设计整体资源利用率一般包括两个，一个是CLB可编程逻辑模块，clb中包括寄存器和lut，第二个是BRAM，主要实现用户的存储需求
>
> 如果设计的CLB或BRAM的资源利用率过高，都会导致设计整体发生拥塞，从设计整体去入手
>
> BRAM这些模块位于FPGA芯片中固定的位置，这些位置会导致布线延迟会高于一般的资源
>
> 根据综合产生的报告，观察哪些某块的利用率特别高，针对这些模块进行优化，将模块资源利用率降下来，从而让设计整体的资源利用率降下来，减轻设计拥塞
>
> 有时候设计整体的资源利用率不是很高，但是某一个模块资源利用率很高，比如某一个模块被多次例化，针对这个模块进行优化
>
> 优化的手段主要是优化分布式ram，分布式ram占用的是clb中的一种专用的lut，这种lut既可以作为分布式ram也可以做为组合逻辑，如果将这种lut作为分布式ram，某些相邻的寄存器就不能用了，这就会导致实际的一些资源被浪费掉
>
> 一般来说主要是优化这些寄存器堆，也就是分布式ram和black ram的大小以及一些信号的扇出太大
>
> 比如说一个fifo的输出数据同时要被四个模块采样，这样扇出就很大，如果不对这个扇出做优化，这些扇出很大的相关信号的布线延迟就会很大
>
> 优化扇出的方法有两种，一种是在xilinx中设置max_fin_out进行设置，这种情况有时候会失效，某些时候这种方法会失效；第二种推荐的方法是手动去复制这些寄存器，（？？？？没有搞太懂）被复制的寄存器在综合的时候要加一些属性，因为综合的时候可能会把这些寄存器当做冗余的寄存器给优化掉

24. 

项目示例

25. 

项目示例

26. 

时序引擎是如何进行holdup检查的

第一步：确定保持时间要求（保持时间的捕获沿-保持时间的发起沿）

> 也就是说要确定保持时间的捕获沿和确定保持时间的发起沿
>
> 保持时间的建立有两种情况
>
>   每一个setup requirement应该对应两个保持时间要求
>
> 第一个保持时间要求是当前建立时间发起沿，发起的数据不能被当前建立时间捕获沿的前一个有效沿捕获到
>
> 第二个保持时间要求就是当前建立时间发起沿的下一个有效沿产生的数据不能被当前建立时间的捕获沿给捕获到
>
> 这两个保持时间要求根据最坏情况考虑，根据最坏情况作为标准
>
> 这两个保持时间其实是相同的，保持时间要求都是0

27. 

换了一对时钟

> 当两个同步时钟有最小公倍数关系时，他们就有多个建立时间需求，每一个建立时间需求右会产生两个保持时间需求
>
> 时序分析引擎会把所有的保持时间都分析出来，找出最大的作为保持时间的标准
>
> 为啥找最大的呢？（保持时间是可正可负的 ）
>
> 分析见笔记
>
> holdup的违例主要是由时钟歪斜导致的

28.  

通过示例计算保持时间需求

29. 

确定保持时间需求，确定用于保持时间分析的发起沿和捕获沿

保持时间需求是以建立时间要求为基础的，保持时间要求有两种

- 当前建立时间的发起沿产生的数据不能被当前建立时间的捕获沿的前一个有效沿捕获到
- 当前建立时间的发起沿的下一个有效沿产生的数据不能被当前建立时间的捕获沿捕获到
- 上面这两句话我感觉描述的是一个意思



保持时间需求要求大的，建立时间需求要求小的

- 建立时间表达的是数据被传递的时间，我们希望越快越好
- 建立时间表达的是数据被捕获后稳定的时间，我们希望越久越好

建立时间需求一定是正的，保持时间需求却不一定，保持时间是可正可负的

- 建立时间的捕获沿是在建立时间的发起沿往右找，也就是说不考虑时钟路径的延迟的话，建立时间需求的捕获沿和发起沿之间有一个时钟的周期
- 当前时刻的保持时间的捕获沿是在当前时刻建立时间的发起沿附近找，也就是说不考虑时钟路径的延迟的话，保持时间需求捕获沿和发起沿之间应该是0

一个关键的问题是保持时间需求或者捕获时间需求的发起沿和捕获沿是如何确定的？

- 如果源时钟和目的时钟是同一个时钟信号，此时保持时间需求为0，建立时间需求为一个时钟周期
- 当情况为A或者B的时候
  - 建立时间需求的确定为源时钟发起数据的发起沿到遇到第一个目的时钟的有效沿作为捕获沿之间的时间
  - 保持时间需求的确定为当前时刻发起数据的发起沿附近的有效沿作为捕获沿的时间，附近有两个有效沿，以大的为准
- A或者B是一句话相位确定就有最小公共周期，有最小公共周期就有最小相位
- A（如果源时钟和目的时钟是由同一个时钟信号产生且信号之间的相位确定
- B（如果源时钟和目的时钟是由同一个时钟信号产生且源时钟和目的时钟具有最小公共周期）

时序引擎是如何进行holdup检查的

第一步：确定保持时间要求（保持时间的捕获沿-保持时间的发起沿）

第二步：计算数据的需求时间

第三步：计算数据的到达时间

第四步：计算hold up 的裕量（slack）

> 计算数据的需求时间，数据的到达时间实际上保持时间发起沿所产生的数据的到达时间，到达目的寄存器的D端的时间
>
> 数据需求时间，是目的寄存器要求，捕获沿目的是要捕获到上一个数据，并不是要捕获到发起沿发起的新数据，如果捕获到新数据，就说明旧数据被冲掉了
>
> 数据需求时间指的是旧数据至少要保持到某个时间点，才可以新数据被刷新掉，旧数据默认保持到的时间点是捕获时间沿加目的时钟的延迟加保持时间

30. 

holdup分析实例

保持时间可以是负数，这是不对的，我们一定要注意区别“保持时间”和“保持时间余量”，保持时间不能为负数，在理想情况下为0；而保持时间余量是可以为负数，这时说明保持时间违例。

31. 

根据公式分析哪些因素会导致holdup slack 为负呢

> holdup slack 为负的情况很少见
>
> holdup slack 小主要是因为Tdata的较小，时序分析在综合时会自动的插入一些延时来使他变大，但是这样会导致setup slack变小，所以需要选择一个适当的延时
>
> 总结：时钟偏斜对setup有利，对holdup有害，路径上的延时对setup有害，对holdup有利

32. 

工程示例

33. 

recovery检查

> 复位就是每一个寄存器有一个复位端口，但不是所有寄存器都是异步复位
>
> 有的寄存器时同步复位端口
>
> 如果寄存器使用异步复位端口，异步复位端口就要进行时序分析，因为要分析异步复位端口上的信号满不满足recovery时间要求和removal的时间要求，一般情况下异步复位都不是纯异步复位，纯异步是复位的置位和释放的过程和时钟完全是异步的，这种纯异步复位的危害很大，释放和时钟异步，时序分析无法分析这个路径，因为不知道他在什么时候释放，有可能在removal时间段复位，轻者导致发生错位
>
> 复位信号进入设计先进行两级触发器的异步置位，同步释放的一个操作
>
> 这两级寄存器可以保证从regBq端输出的复位信号可以作为设计的异步复位信号，置位和时钟是异步的，释放和时钟是同步的，释放和时钟同步就可以保证时序分析引擎可以进行正确分析
>
> 一般进行recovery和removal检查的时候分析的时序路径和setup 和holdup分析的时序路径不一样，setup和holdup分析时序路径的时候将设计中的每两个寄存器作为一个时序路径，直到将所有寄存器遍历到
>
> recovery 和removal分析的时候可能是以regb作为一个源寄存器，目的寄存器可以是设计中被复位的所有的寄存器，所有源寄存器是固定的，目的寄存器时所有需要复位的寄存器

34. 

时序分析引擎是如何进行recovery检查的

> recovery检查和setup类似的，这二者对于触发器比较类似都是要求时钟上升沿的一段时间，计算方式和setup的很类似

35. 

工程示例

> recory 违例相对比较常见，复位信号驱动的寄存器很多，甚至驱动所有的寄存器，一般来说并不是所有寄存器都需要异步复位的，有些寄存器根部不需要复位
>
> 比如说fifo的写使能和写数据信号，写使能是控制信号，必须要复位，对于写数据信号在写使能为低的时候，写数据信号不管为多少都写不进去
>
> 所以写数据信号一般推荐不用复位，如果需要复位与不需要复位的信号都复位了，复位信号的扇出就会很大，扇出很大就会导致复位信号从regb连接到任何一个目的寄存器的延迟就比较大，延时比较大的时候就容易导致recovery违例
>
> 需要复位的信号一般有控制信号，状态机，带有反馈的电路
>
> 不用复位的信号，比如一些数据总线上的流水是不用复位的
>
> 修recovery违例时先把设计中的复位信号检查一下， 将不需要复位的信号去除掉
>
> recovery故障：recovery违例会导致目的寄存器在下一个时钟才会从复位状态进入非复位状态，这就会导致recovery故障
>
> recovery故障就是说部分寄存器比其他寄存器晚一个时钟沿跳出复位状态，这就有可能导致系统一上电就程序就崩溃
>
> 尤其是对一些读热码状态机，这导致了部分比特从复位状态到非复位状态不是一个时钟沿来完成的，先释放的比特就可能进入一个非法的状态，就有可能让状态机跳不出来了
>
> 所以recovery分析就是为了rega在launch edge释放复位，同时让所有目的寄存器在同一个时钟沿统一的跳出复位状态
>
> 设计不满足recovery分析也不一定会出现recovery故障，但是满足recovery分析可以杜绝recovery故障

36.  

时序引擎是如何进行removal检查的

removal类似于holdup分析，通常来说不会出现违例

> 如果出现违例，那么时序分析引擎就会引入一些数据延迟，来消除违例，通过插入延时，一般都可以自动的把违例修复过来  

37. 

工程示例

>  也会导致removal故障
>
> 一般来说，要保证每个模块都不会出现removal故障

38. 

时序约束主要包括什么

> 时序引擎之所以能正确的对这四种路径进行分析，是因为用户必须通过时序约束提供一些必要的准确的信息，才能正确分析，否则时序分析的结果是不可靠的
>
> 有一些时序信息，时序引擎是可以自动进行推断的，推断信息不一定是正确的，如果错误了人如何修改
>
> 第一种就是要高速他input delay 以及数据输入以什么时钟进行采样，时钟频率，相位都要高速他
>
> 第二种路径就是约束源时钟和目的时钟，如果时序引擎推断setup与用户真正意图不符时通过其他约束修复他
>
> 第三种提供output dealy
>
> 第四种提供max delay和min delay，max delay就是约束组合逻辑的的最大延时，时序分析时会分析组合路径的延迟，如果超过约束的延迟则认为时序违例

39. 

时钟约束

> 通过pll/mmcm产生的生成时钟，vivado可以自动的对这类时钟推断的，每一个生成时钟都会对应一个时钟源，就是master clock，用户需要约束的就是master clock，这种生成时钟的周期，时钟占空比都可以自动推断的。
>
> 例化pll的时候就已经告知他这些信息的，生成时钟相当于是master clock经过了相移，分频，倍频，反相这一系列操作产生的时钟，具体进行什么操作，在例化pll是已经给出了，再加上约束过的master clock，所以根据这两个信息，可以知道生成时钟是怎样的
>
> 时钟选择器产生的时钟非常不靠谱，因为他是通过用户自己的逻辑产生的，一般不建议使用，时钟质量不行，驱动能力不够，不能用它驱动好多个信号，用它驱动好多个信号会导致时钟歪斜会比较大
>
> 如果要通过寄存器或lut产生的时钟，在生成时钟之后，在时钟后面加一个bufg 降低时钟歪斜，但是使用bufg之后又会导致时钟延迟比较大
>
> 所以总的来说不建议使用，如果使用了一定要加一个约束，因为vivado不止到用户使用寄存器或者lut对时钟进行了一个怎样的变化，所以需要约束

40. 

主时钟约束

```tcl
create_clock -period 10 [get_ports sysclk]
## get_ports 指定时钟的源节点，也就是source point 
## 每一个时钟都是有一个源节点的，通常来说主时钟的源节点就是这个全局时钟的输入的引脚
## 源节点指定非常重要，如果指定在bufg输出的位置，时序引擎在分析的时候从输入引脚到bufg的输入这一段的路径延迟就不会被考虑进来
## 约束主时钟的时候源节点一定要约束在FPGA的全局输入时钟引脚上，这样整条路径上的延迟都会被考虑到，否则这些延迟就相当于被bypass掉了
##占空比50%，相移位0的话是一个默认的情况，不用进行额外的约束
```

41. 

如果主时钟相移不是0，占空比不是50%，怎么办、

```tcl
create_clock -name devclk -period 10 -waveform {2,5 5} [get_ports ClkIn]
## 约束主时钟就谁create_clock，可以变得是多加这条命令的其他一些选项
## -name 是给时钟起了一个时序分析的名字，只在看时序路径的时候有用，在代码里并没有这个名字
## -waveform 约束占空比，{第一个上升沿的时间点 第一个下降沿时间点}，从而得知波形
## ClkIn，指定主时钟的一个源节点，这个源节点是全局时钟的一个输入引脚
## devclk相当于是对ClkIn进行一个命令，只在时序分析时起作用
```

42. 

第二种是高速收发器输出给用户的恢复时钟

```tcl
create_clock -name rxclk -period 3.33 [get_pins gt0/RXOUTCLK]
## get_pins 指示这个时钟的源节点，源节点一定得指定在gt0的输出的pins上不能再mmcm的输入上，否则会忽略一段延时
## get_pins 是指一个模块的输入输出端口是pins，FPGA的输入输出端口是ports，两个模块之间的输入输出的端口时使用nets进行连接的
```

> 总结
>
> ports FPGA的输入输出端口叫ports
>
> pins 内部模块的输入输出端口叫pins
>
> nets 内部多个模块之间的连接叫nets

43. 

生成时钟的约束

> 生成时钟约束的命令与主时钟约束的命令不相同，生成时钟使用create_generated_clock进行约束
>
> 每个生成时钟都会对应一个时钟源（master_clk）这个时钟可以是primary clock 或者另外一个generated clock
>
> 生成一定要使用使用-source进行指定时钟源，灵活度比较高，可以指定时可以是时钟源的源节点（比如说时钟源是主时钟，就是全局时钟的输入引脚），或者mmcm的输入端，从指定的时钟源进行推断，最后都会到主时钟，也就是最后结果一样
>
> 约束生成时钟的时候不需要描述生成时钟的周期和波形，只要描述有master_clk经过怎样的变化产生的，比如经过分频（-devided_by），倍频（-multiply_by）， 反相（-invert），相移（-edge_shift）等操作

44. 

示例

 ```tcl
##首先约束主时钟
create_clock -name devclk -period 10 [get_ports clkin]
## 然后约束生成时钟
create_generated_clock -name clkdiv2 -source [get_ports clkin] -devide_by 2 [get_pins REGA/Q]
## or 
create_generated_clock -name clkdiv2 -source [get_pins REGA/C] -devide_by 2 [get_pins REGA/Q]
## -name 是给他指定一个在时序分析时的名字
## -source指定master clock的位置，这个可以指定两个位置，一个是ports，一个是pins
## -devide_by 2 将主时钟二分频产生的生成时钟
## -get_pins 定义生成时钟的端口，生成时钟是在rega的q端产生的，所以必须定义在这
 ```

45. 

divide_by 2 的另一种写法，

```tcl
##
create_generated_clock -name clkdiv2 -source [get_ports clkin] -edge {1 3 5} [get_pins REGA/Q]
## 以master clock为基准，将生成时钟的上升沿和下降沿编号，生成时钟与主时钟的第一个上升沿的对齐位置的编号，第一个下降沿对齐的位置编号，和第二个上升沿对齐的编号
```

46. 

当生成时钟需要相移时使用-edge_shift选项

edge_shift 不能与divide_by/multiply_by/-invert同时使用

```tcl
create_clock -name devclk -period 10 [get_ports clkin]
## 首先这个时钟一般不用描述，只要描述对应的主时钟就行，如果要手动约束也是可以的，一定要约束到时钟输出的那个点，如果用户没有约束vivado会自己推断
## 这句话要从左往右看，一个属性一个属性的分析，-edges是1，2，3说明这个生成时钟的频率和源时钟的时钟频率相同，使用-edge确定了周期
## 确定了生成时钟的周期，然后指定第一个上升沿，第一个下降沿，第二个上升沿的偏移量
create_generated_clock -name clkshift -source [get_pins mmcm0/CLKIN] -edges {1,2,3} -edge_shift {2.5 0 2,5} [get_pins mmcm0/CLKOUT]
## 先定波形，在定偏移量确定占空比，二者的顺序不能颠倒
```

> 自己约束的好处是可以给生成时钟起名，这样查看时序分析的时候方便一点，这算是一个比较复杂的生成时钟了，掌握这个例子就差不多解决一些问题了

47. 

时钟分组

> 时序引擎默认情况下会认为所有时钟都是同步的，可能这两个时钟来自不同的晶振，但是他不知道，他就会把这两个时钟进行时序分析
>
> 但是这两个时钟是异步的，也就无法确定相位关系，更无法准确的找出捕获沿和发起沿，捕获沿和发起沿是任意的，而且会随着温度的变化而改变
>
> 如果没有告知时序引擎，时序引擎就会分析，所以在约束完时钟后，要把时钟进行分类，每两个时钟之间的关系进行分类，是属于同步的还是异步的，还是不可扩展的，知道时钟之间的关系之后，时序分析引擎就只会分析同步时钟关系的路径异步时钟就会被忽略掉
>
> 被忽略掉的时钟不一定是能够正常工作的，这些跨异步时钟域的路径经常通过两级触发器同步，异步fifo，异步ram，握手等方式保证异步时钟正确传输，异步时钟路径之间数据能否正确传输是用户保证的

48. 

同步时钟，异步时钟

> 同步时钟的条件——他们的相位关系可以确定
>
> 两个时钟来源于同一个primary clock，他们不一定是同步时钟
>
> 两个时钟来源于不同的primary clock，他们一定不是同步时钟
>
> 两个是时钟的相位关系可以确定，他们一定是同步时钟，因为两个时钟如果来源于不同的primary clock，他们的相位关系一定不可以确定；两个时钟来源于同一个primary clock 时有两种情况，一种是最小公共周期是整数，一整没有确定的最小公共周期，有确定最小公共周期的是同步时钟，没有最小公共周期的不是同步时钟
>
>  最小公共周期是整数 = 相位关系可以确定 吧？？？感觉应该是
>
> 如果两个时钟没有最小公共周期，这就会导致时序引擎计算发起沿和捕获沿的时候没有办法找到最差的setup requirement，时序分析引擎就会在1000个时钟周期中找到一个最差的，但是此时的分析结果已经不可靠了，虽然分析了1000个时钟周期，但是不能保证1000个周期之外没有更差的情况
>
> 两个时钟之间的相位关系不确定，这两个时钟就是异步时钟，异步时钟关系无法进行正确的时序分析

49. 

不可扩展时钟

来源与同一个primary clock的两个时钟，没有整数的最小公共周期，他们之间的相位关系就不可确定，这类时钟是不可扩展时钟关系

总结：异步时钟和不可扩展时钟之间的路径都无法进行正确的时隙分析，所以在时序分析之前，需要使用set_clock_group对时钟进行分组，从而将这些无法进行时序分析的路径忽略掉，忽略掉之后用户需要通过各种手段保证他可以完成正常的传输，降低亚稳态向下传播的概率

> 同步时钟，异步时钟，不可扩展时钟，都是形容两个时钟之间的关系，
>
> 划分同步异步的条件是是否来源与同一个primary clock，划分同步与不可扩展的调校是有没有最小的整数的公共周期，时序引擎可以分析的是相位关系确定的时钟，两个时钟关系只有是同步时钟他们才可以进行时序分析

50. 

时钟分组示例

> 有时候mmcm产生的两个时钟的名字是不确定的，因为mmcm的生成时钟的名字是有vivado自动推断的
>
> 可以使用命令查看名字也可以使用第二种分组方法

```tcl
## 默认一个组里的三个时钟都能找到最小的整数时钟周期
set_clock_groups -name asyn_clk0_clk1 -asynchronous -group {clk0 usrclk itfclk} -group {clk1 gtclkrx rtclktx}
## or
set_clock_groups -name asyn_clk0_clk1 -asynchronous -group {get_clocks -include_generated_clocks clk0} -group {get_clocks -include_generated_clocks clk1}
## 这样将同步和异步时钟分开了，那么时序引擎在分析的时候只会分析同一组中的两个时钟之间的路径
## clk0和clk1之间的时序路径就不会分析了
```

51. 

说完时钟关系，时序约束中第二种路径就可以分析了

52. 

时序约束后时序引擎如何进行第二种路径的时序分析

> 主时钟约束，生成时钟约束，时钟分组约束，时钟周期约束，这些约束做完之后，时序引擎分析第二条路径的过程
>
> 保持时间的发起沿和捕获沿通常来说是同一个跳变沿
>
> 保持时间发起的数据经过1，2，3延时后到达目的寄存器的数据输入端口，到达端口的是新数据，到达端口的时间点也是数据刷新的时间
>
> 保持时间的捕获的数据是在新数据之前的，当目的寄存器检测到捕获沿的时候，捕获沿应该想要捕获的是新数据之前的数据，即目的寄存器端口在新数据之前的数据
>
> 如果数据刷新的时间点太靠前了（数据路径的延迟太少），捕获沿可能就没有办法捕获到有效的数据，相对来说旧的数据就有可能被新的数据冲刷掉了

53. 

input delay

> 上游芯片发起数据到FPGA的第一级触发器，这一条路径已经被分割成两段了，时序分析引擎只能分析FPGA内部的一段的延时情况，前半段在FPGA外部，延时情况是不知道的，除非用户通过 input delay进行约束然后才可进行时序分析，input delay 数据进入FPGA输入端口的延迟相对于时钟在FPGA时钟上升沿的一个相移
>
> input delay可以正可以负

54. 

如何计算input delay 

55. 

Tclk1 - Tclk2

假设时序引擎知道1，2，3 的延时，但是其实是不知道的

56. 

计算input delay

> input delay就是外部1，2，3 的和
>
> MAX input delay = Tco（MAX） + Tpcb（MAX） - clk_skew（MIN）
>
> input delay 一般是用来分析setup 或者recovery的，时序引擎分析的是最差的情况，input delay 越大，setup或者recovery越容易违例
>
> 通常情况下是不知道这几个时间的，一般情况下降input delay 约束为60%
>
> 也就是说用户的延迟只能打到时钟周期的40%

57. 

MIN input delay

MIN input delay = Tco（MIN） + Tpcb（MIN） - clk_skew（MAX） 

> MIN input delay是用来进行holdup 和removal分析的
>
> 时序引擎是不知道1，2，3的延迟的，需要自己估计和计算

58.

约束input delay 的命令

> 因为这是一个相对的概念
>
> input delay代表一个相位差，相位差他就是相对的，数据到达FPGA输入输出端口和时钟上升沿到达输入输出端口的相对差值
>
> 必须首先约束clock，因为时钟要对数据采样，这个input delay 实际上是数据的输入端口稳定的时间点相对于FPGA全局时钟检测到有效沿的点的差
>
> 相位差其实就是1，2，3的和

```tcl 
create_clock -name sysCLK -period 10 [get_ports CLK0]
set_input_delay -clock sysCLK 2 [get_ports DIN]
## or 
create_clock -name sysCLK -period 10 [get_ports CLK0]
set_input_delay -clock sysCLK -max 4 [get_ports DIN]
set_input_delay -clock sysCLK -min 1 [get_ports DIN]
```

```tcl
## 约束ddr的例子
create_clock -name clk_ddr -period 6 [get_ports CLK_IN]
set_input_delay -clock clk_ddr -max 2.1 [get_ports CLK_IN]
set_input_delay -clock clk_ddr -max 1.9 [get_ports CLK_IN] -clock_fall -add_delay
## 约束的为同一个时钟，如果想不覆盖前一个约束，就需要一个add_delay命令
set_input_delay -clock clk_ddr -min 0.9 [get_ports CLK_IN]
set_input_delay -clock clk_ddr -max 1.1 [get_ports CLK_IN] -clock_fall -add_delay

```



59. 

什么是 output delay

output delay用于约束最后一级触发器与FPGA输出端口之间的时序关系

> 时序引擎只知道FPGA内部的时序信息，外部的信息需要通过约束告知时序引擎

60. 

如何计算output delay

61. 

标记延迟

62.

计算公式

max output delay = Tpcb(Max) + Tsu - Clk skew(Min)

> 4，5，6参数，一般芯片手册可以查到
>
> 如果不知道一般将output delay约束为时钟周期的60%
>
> output delay相当于仍是在数据路径上叠加的延迟  

63. 

min output delay  = Tpcb(Min) - Th - Clk skew(Max)

> min output delay是用来做 holdup分析的，类似于inputdelay
>
> output delay 越小，旧数据越容易被新数据冲刷掉

64. 

如何约束output delay

> 如果不知道最大最小的话，可以直接约束为60%，既可以用于最大的outputdelay 也可以用于最小的

```tcl 
create_clock -name sysCLK -period 10 [get_ports CLK0]
set_output_delay -clock sysCLK 6 [get_ports DOUT]
## 关于ddr上下沿的约束 
create_clock -name clkddr -period 6 [get_ports CLK0]
set_output_delay -clock clkddr -max 2.1 [get_ports DOUT]
set_output_delay -clock clkddr -max 1.9 [get_ports DOUT] -clock_fall -add_delay

set_output_delay -clock clkddr -min 0.9 [get_ports DOUT]
set_output_delay -clock clkddr -min 1.1 [get_ports DOUT] -clock_fall -add_delay
```

65. 

多周期的约束

> 多周期的约束并没有接触过,大多数项目也不会用到多周期约束
>
> 因为一般来说同步时钟中，信号在跨时域时，我们一般做做跨时钟处理
>
> 这样做的问题是比如两个时钟是从一个pll出来的有最小公共周期的信号，有信号要跨时钟域时，一般的做法是做一个跨异步时钟域处理，但这是完全没有必要的，跨异步时钟处理会使性能下降
>
> 跨同步时钟域时就需要多周期约束，两种情况采用多周期约束，一个是跨同步时钟域处理，第二个情况是用户希望放松某些路径的约束
>
> 在实际中，源时钟和目的时钟路径是同步时钟且有最小公共周期，没有必要做跨异步时钟处理，比如一个pll产生一个100m和200m的时钟，在200m时钟域做一个时钟使能信号，每两个快时钟信号采样一次100m时钟域的数据，这样做也完全没有问题，对性能也没有影响，也不用浪费异步fifo
>
> 100m和200m做了跨异步时域处理，就不用多周期约束，这两个时钟相当于是看做异步时钟了，异步时钟处理就是之前说的要么把这两个是时钟分在两个组了，要么设置为为路径set_false，这样两个时钟域之间的路径就不用分析了
>
> 当做跨同步时钟处理时，通过约束把路径重新约束，因为时钟引擎选择的捕获沿和发起沿很大可能是错误的，通过约束修改后，就可以进行正确处理了
>
> 第二种情况是源时钟和目的时钟都是100m，但是源寄存器时每两个是时钟产生一次数据，目的寄存器两个时钟捕获一次数据，这时，建立时间需求就不是一个周期，是两个周期就可以通过多周期约束将时序约束放宽
>
> 多周期的约束命令
>
> setup有两种调整方式，一种是调整setup的捕获沿，将捕获沿向右推，另一种是调整setup的发起沿，发起沿向左推，都是将建立时间需求扩大
>
> 调整holdup捕获沿或者保持时间的发起沿，调整时只能选择一个，要么调整捕获沿要么调整发起沿
>
> -end调整保持时间捕获沿，把保持时间捕获沿向左推
>
> 调整发起沿，将发起沿向右推
>
> 调整setup不指定-start或者-end，默认使用-end，调整建立时间捕获沿
>
> 调整holdup默认调整保持时间发起沿

66. 

多周期setup holdup 约束方法

67. 

> 源时钟和目的时钟相同的情况下，这种情况一般比较少见
>
> 不进行多周期约束时捕获沿和发起沿的确定
>
> 第一步，确定最小公共周期，源时钟和目的时钟周期相同，比如周期为4ns
>
> 第二步，在4ns内从源时钟找发起沿，也就只要一种情况，是0ns的发起沿
>
> 第三步，以这个发起沿为基准，向右推，找到第一个捕获沿的位置，也就是第一个目的时钟上升沿，作为捕获沿
>
> 确定唯一一个setup requirement建立时间需求
>
> 保持时间确立以建立时间为基础的，以这一个建立时间需求为基准，确定两个保持时间需求
>
> 保持时间的两种情况，第一种当前建立时间发起沿产生的数据不能被当前建立时间捕获沿的前一个有效沿捕获到，将0ns的目的时钟的上升沿作为保持时间捕获沿，第二个holdup requirement是当前建立时间发起沿下一个有效沿发起的数据不能当前捕获沿捕获到，相当于4ns时刻作为保持时间发起沿，4ns目的时钟作为保持时间捕获沿，在这个例子中，这两个hold requirement 都是0ns
>
> 虽然一样，但是我们知道时序引擎分析的时候以一个setup requirement为基础，寻找两个holdup requirement ，然后从两个中选出一个最大的作为分析的标准

68. 

> 如果不进行多周期约束是没有问题的，只不过默认的时序约束标准比较严苛，这样带来的后果是将优化资源浪费在这条虚假的关键路径上，本来建立时间10ns，非要优化到5ns，造成优化资源浪费，导致别的关键路径优化资源不够，最好的做法就是将应该放松时序约束的路径用多周期路径将他放松下来，这样节省优化时间和提升综合优化的结果

```tcl
## 设置多周期约束的方法
## 2代表是调整的时间，因为是setup，所以相当于是调整建立时间需求
## 默认情况下是-end作为标准，修改的是建立时间的捕获沿
## 将原来建立时间的捕获沿向右推一个时钟周期改为向右推2个时钟周期
## -from指定时序路径的起点
## 时序路径起点只有两种可能，
## 		一种是某一个寄存器的时钟端，一种是fpga的数据输入端口
## -to指定时序路径的终点
## 时序路径的终点只有两种可能
##		一种是目的寄存器的数据输入端，一种是fpga的数据输出端口
set_multicycle_path 2 -setup -form [get_pins data0_reg/C] to [get_pins data1_reg/D]
```

69. 

多周期约束后的效果

> holdup requirement是以setup requirement为基准的，所以调整setup requirement进行调整后，holdup requirement也会进行调整，调整时仍然以默认方式进行调整
>
> 进行多周期约束时，setup requirement修改后，holduprequirement也会进行修改，holduprequirement修改有可能是对的有可能是错的，对的不用管，错的就要进行调整
>
> hlodup requirement跟着setup requirement 变化后，是变大了，hlodup requirement越大约容易违例，我们进行多周期约束的目的就是放松时序约束，但是hlodup requirement变大并没有放松反而变紧了，所以也要对hlodup requirement进行多周期约束

70. 

调整保持时间需求

```tcl
## 保持时间需求与监理时间需求相同
## -end用来调整保持时间的捕获沿，捕获沿调整一般向左移
## 这个1是保持时间捕获沿在原先holdup requirement默认基础上向左移一个周期
## 调整后如ppt所示
## 在clock enable有效的时候源时钟0ns发起一个数据，不要被目的时钟0ns捕获到，这样就满足了需求
set_multicycle_path 1 -hold -end -from [get_pins data0_reg/C] -to [get-pins data1_reg/D]
```

71. 

    这页ppt有问题，图中修改的是保持时间的捕获沿的位置，而命令修改的是保持时间的发起沿

对每四个时钟发起一次数据的路径进行多周期约束

```tcl
## 先调整-setup
## 没有指定-end还是-start，调整-setup默认是-end为调整依据，也就是调整的是建立时间的捕获沿
## 捕获沿在调整之前是向右推一个时钟，现在向右推4个时钟
set_multicycle_path 4 -setup -from [get_pins data0_reg/C] -to [get_pins data0_reg/D]
## 调整-setup后，-hold也会默认跟随变化
## 变化后-hold变成三个时钟周期，如果数据路径延迟没有三个时钟周期，那么你就会违例
## 所以使用下面的命令修改-hold
## 没有指定-start还是-end -hold默认修改-start的值
## 修改的是保持时间的捕获沿
set_multicycle_path 3 -hold -end -from [get_pins data0_reg/C] -to [get_pins data0_reg/D]
```

72. 

这个ppt 使用-start调整的

约束五个时钟发起一次数据

```tcl
## 调整了建立时间，保持时间跟随变化，所以需要调整保持时间
set_multicycly_path 5-setup -from [get_pins data0_reg/C] -to [get_pins data1_reg/D]
```

73. 

调整保持时间-start

```tcl
## 默认使用-start 
## 调整保持时间发起沿，向右调整，
set_multicyclt_path 4 -hold -from [get_pins data0_reg/C] -to [get_pins data1_reg/D]
```

> 没有时钟使能为什么调整到这个位置
>
> 实际上调整到这只是得到一个保持时间的值，在分析时建立时间需求调整的值，在保持时间发起数据的时候就进行分析

74. 

源时钟和目的时钟频率有一个正向偏移

例子是目的时钟比源时钟偏移0.3ns，属于正向偏移，比较常见

> 建立时间需求默认只有0.3ns，分析一下就知道了，建立时间发起沿向右推遇到的第一个有效沿作为捕获沿，得到建立时间需求，正向偏移0.3ns之后建立时间需求就只有0.3ns了
>
>  建立时间的捕获沿和发起沿，保持间的捕获沿和发起沿如ppt所示，时序引擎默认的建立时间需求和保持时间需求大概率是不会被满足的，所以通过多周期约束

75. 

偏移量的调整，正向偏移调整效果为ppt所示

人为的偏移量和在路径中真实存在的偏移量是不一样的，时序引擎只能分析出真实存在的偏移量，这个偏移量就是时钟偏斜，当两个相同频率的同步时钟之间存在相位差时是需要通过多周期约束进行一个修正的

```tcl 
## 首先对setup进行约束，默认是-end，也就是捕获沿
## 捕获沿的调整默认向右推，向右推两个时钟周期
## 也就是将捕获沿由原来的第一个上升沿调整为遇到的第二个上升沿
set_multicycle_path 2 -setup -from [get_clocks CLK1] -to [get_clocks CLK2]
```

> 在调整完-setup后，-hold 的变化是正确的，但是这个变化结果是正确的，因为在0.3ns发起的数据就是不能被此时保持时间的捕获沿捕获到，此时捕获到的是旧数据

76. 

负向偏移一般不用调整，除非这个偏移量很大，相位差超过-180度，此时也是需要进行调整的

> 负向偏移不大的时候就是让时序紧了一点，这时候建立时间需求是可以捕获到，当然也可以进行调整，这样做对性能有影响，会导致数据隔了多半个时钟周期

77. 

源时钟和目的时钟频率不同（源时钟慢，目的时钟快），这种是跨同步时钟域处理

> 目的时钟频率是源时钟频率的三倍，此时有两种方法处理这种情况
>
> 直接当做异步时钟进行处理，约束时好约束，不用多周期约束，这条时序路径使用异步分组或者伪路径约束后，时序引擎就不分析了，坏处是影响性能，一般来说发起沿向异步fifo写数据，内部做跨异步时钟处理，经过多个时钟处理读端口才能读到数据，这些延时如果用多周期约束的话是不用的
>
> 第二种情况用跨同步时钟域处理，在源时钟发起数据后，在第三个上升沿捕获数据就可以了，当然也可以不做多周期约束，在第一个上升沿捕获数据，这样做的好处是时序约束更紧，这样对性能可能有提升，但是如果不是必须在第一个上升沿捕获数据的话，可以不浪费这个优化资源，对其他关键路径的优化也是有好处的

78. 

修改多周期约束

```tcl
## 当发起沿与捕获沿的时钟域不同时，调整setup 要灵活使用end 和start
## -end调整捕获沿，-start调整发起沿，调整的时钟周期以他们所在的时钟域为准
## 比如-start调整的是建立时间发起沿，发起沿向左调整一个时钟周期，整个setup requirement会变成12+4
## 默认使用end就刚好，因为使用-end调整后，setup requirement 会变成12ns
## 多周期约束调整只能以周期来调整，这就是为什么约束多周期时会给两个选项，优势调整捕获沿比较好，优势调整发起沿比较好
set_multicycle_path 3 -setup -from [get_clock CLK1] -to [get_clock CLK2]
set_multicycle_path 2 -hold -end -from [get_clock CLK1] -to [get_clock CLK2]
```

79. 

> 当时钟周期不同，意味着保持时间和建立时间的发起沿和捕获沿不再同一个频率的时钟下，多周期约束的关键是找到捕获沿和发起沿并且知道这是哪个数据的捕获沿和发起沿
>
> 多周期约束时可以约束目的寄存器和源寄存器之间的时序路径，也可以像这张ppt一样约束两个时钟的捕获沿和发起沿

80. 

源时钟和目的时钟频绿不同的情况（源时钟快，目的时钟慢）

> 首先还是寻找最大的公共周期，源时钟是目的时钟的三倍，在12ns中建立时间的捕获沿可能出现的位置只有一种
>
> 找目的时钟的捕获沿只有一种可能，以捕获沿为基准，找发起沿比较方便，以捕获沿为基准，向左推1个源时钟的周期就是时钟的发起沿，也只有唯一的一种setup requirement，向前推2个周期或者向左推两个周期都不是正确的setup requirement，这种setup requirement的建立时间分析是12ns，相对于向前推一个时钟周期也就是4ns 的建立时间，时序引擎在分析的时候是以最差情况分析，所以向前推两个时钟周期的建立时间是没有意义的
>
> 确定了建立时间后，新的保持时间也会随着改变，这中情况下，源时钟发起数据的速度快，目的时钟捕获数据的速度慢，会导致少捕获数据，旧数据没被捕获，也就是数据的保持时间没有被满足，这样会出现问题的，除非你的源时钟三个周期发起一个数据，这样通过多周期约束是可以解决问题的，源时钟发起数据要和目的时钟捕获数据的速率相匹配
>
> 假设现在你是三个源时钟周期发起一次数据，我们调整建立时间时，能不能调整建立时间的捕获沿呢，答案是不能的，把建立时间的捕获沿向右调整一个周期会使建立时间变成12+4ns，这样显然与实际不符实际的
>
> 这时只能调整建立时间的发起沿，建立时间的发起沿应该向右调整两个源时钟周期

81. 

约束代码

> 对于快到慢的多时钟约束是有要求的并不是说你想用就用，如果发起的数据都是有用的，你就算用来多周期的约束还是会出现问题的，这时只能通过跨异步时钟的操作来完成数据的正确传输

```tcl
## 调整的周期数是这样的，时序引擎分析后会以比较严苛的建立时间要确定捕获沿和发起沿，而建立时间的捕获沿只有一种情况，确定了捕获沿后，在源时钟时钟域向前推一个时钟周期确定发起沿，从而确定建立时间，但这是严苛的我们要通过多周期约束将时序要求放松，
## 放松就是将原来确定发起沿向前推一个时钟周期的标准变成向前推三个时钟周期（本例中），而不是累加，原来1个，在加2个，这样确立的建立时间需求就比较松了
set_multicycle_path 3 -setup -start -from [get_clocks CLK1] -to [get_clocks CLK1]
## 以新的setup作为基准，holdup会调整到建立时间发起沿的下一个时钟周期，也就是4ns的地方，此时要将保持时间捕获沿也是在目的时钟域有两个位置，一个是4ns的位置，另一个是12ns的位置，显然4ns的位置对于目的时钟域是不合适的，应该在12ns处，也就是要将保持时间发起沿从4ns调整到12ns的位置，对于源时钟域来说是两个时钟周期，调整保持时间向右调整两个周期
## 还是同样的原因所以不能调整保持时间的捕获沿
set_multicycle_path 2 -hold -from [get_clocks CLK1] -to [get_clocks CLK1]

```

82. 

FalsePath伪路径约束

falsepath 路径是指该路径在拓扑结构中的确存在，但是并不工作，或者不用进行时序分析，通过伪路径约束我们可以减少时序分析的时间，提升设计优化的效果

```tcl
set_false_path [-setup] [-hold] [-from <node_list>] [-to <node_list>] [-through <node_list>]
## -from/-to的node_list 必须是有效的时序路径的起点和终点，或是时钟
## 如果是起点或终点，就是把某一条具体的路径不分析了
## 如果是-from clk0和-to clk1相当于是以clk0为源时钟的时序路径和以clk1为目的的时钟路径不分析了，但是clk1位源时钟和clk0为目的时钟还是会分析的，也就是说他是单向的 
## -through的node_list应该是ports/pins/ports
## 在某些时候，很难找到所有的时序路径的起点和终点，使用-through命令后面是某一个模块的pins，或者两个模块之间的nets，使用这个命令会把凡是经过这pins的时序路径都bypass
```

> 不需要时序分析的路径，单比特信号跨异步时钟，已经两级触发器同步了，从源时钟的q端或clk端，到目的时钟的第一级寄存器的路径，这样的路径是不用分析的，已经由用户保证了时序分析的稳定性了
>
> 一般来说，异步复位路径时序路径都是不需要分析的，也没有办法分析
>
> 伪路径约束是不进行时序分析和优化的，这条路径能不能正确工作完全靠用户，如果只是放松时序，应该用多周期约束

83. 

伪路径命令约束

```tcl
## 将异步复位信号设置为伪路径
set_false_path -from [get_port reset] -to [all_registers]
## 将CLKA到CLKB的单向路径设置为伪路径
set_false_path -from [get_clocks CLKA] -to [get_clocksCLKB]
## 将CLKB到CLKA的单向路径设置为伪路径
set_false_path -from [get_clocks CLKB] -to [get_clocksCLKA]
```

> 当有多个异步时钟之间的路径需要设置为伪路径时，推荐使用set_clock_group的命令

84. 

FalsePath约束举例

> 从图中可以看出，两个mux的选通信号是一样的，在实际中两个mux的选通端只有选通00，或者选通11，不会出现01或者10，但是时序分析引擎在分析时还是会分析10或者01路径，这是就要通过falsepath进行约束这两条路径
>
> 异步复位，跨异步时钟域，不工作的路径，这几种情况需要用到set_false_path

```tcl
set_false_path -through [get_pins MUX1/a0] -through [get_pins MUX2/a1]
```

85. 

maxdelay约束

> 可以代替多周期约束

86. 

> 跨时钟域一般有两种情况，
>
> 一种是单比特，如ppt所示，单比特用两级触发器做同步
>
> 发起数据的寄存器和目的寄存器之间的位置要尽量摆放的近一点，这样会减少数据延时，增大MTBF，降低亚稳态出现的概率，但是在单比特跨时钟域时又要使用set_false_path或者set_clock_path命令后时序引擎将其时序路径bypass掉，  这时综合工具不会对这条时序路径进行优化（提升时序分析的速度），这样导致时序引擎可能在优化别的路径时可能会将这两个触发器的位置放的比较远，因为使用上面的命令后，就不进行优化，也就是对发起数据的寄存器和目的寄存器之间的位置没有严格约束，这样做对于单比特的传输会影响性能，就是在发起数据后经过几个时钟周期才能捕获到，就是降低了性能，但是还能正常工作
>
> 一种是多比特，异步fifo，异步ram，握手等
>
> 多比特信号为什么不能用两级触发器呢，因为比如有一个两比特信号从00到11，这时是有两条时钟路径的，这两个比特在跨时钟域时，并不能保证同时到达，有可能导致采样到01或者10，这是比较危险的，也就是会使电路进入不正常的状态，在使用格雷码后，只有1bit发生变化，这时相邻变化采样到的信号要不是旧数据，要不是新数据，不会有别的情况
>
> 但是使用给格雷码需要一个条件，就是源时钟域产生的格雷码到目的时钟域采样格雷码这两个寄存器不能放的太远，尤其是不能超过一个目的时钟的延时
>
> 所以这时约束为伪路径后，延时就有可能超过一个目的时钟周期，这时对发起数据的寄存器和目的寄存器之间的位置有了要求，简单的设置伪路径或者异步时钟组是不能满足这要要求的，这时我们就要使用maxdelay来约束，相当于约束源寄存器的q端到目的寄存器的D端的这段时序路径的一个延迟，这段时序路径的延迟不能超过maxdelay，如果源寄存器和目的寄存器放的太远，延时超过maxdelay就会导致时序违例，所以这时会对这段时序路径进行优化
>
> 在多比特使用格雷码时，读写地址在跨时钟域时

87. 

什么情况下使用maxdelay 

> 如果设计中使用了带格雷码控制的fifo来实现异步时钟域来隔离的话，就不能使用伪路径或者异步时钟组来约束，要使用maxdelay来约束
>
> 而且要用set_max_delay -datapath only来进行约束，这个约束还是对异步路径来约束的，源时钟和目的时钟还是异步时钟，这个only是用来忽略时钟歪斜的，实际上就是不分析源时钟和目的时钟之间的路径，只分析这个数据路径延时

88. 

> 如果仅将读写时钟用set_clock_groups约束为异步时钟，相当于设置从A到B和从B到A的路径全部falsepath，falsepath优先级最高，很显然这么做会导致所有跨读写时钟域的路径全部不做时序分析，读写指针和相关控制逻辑也失去了意义

89. 

如何使用maxdelay约束

> 如图中所示，在clka下产生格雷码，在clkb下捕获格雷码，clka是500M的时钟，clkb是100m的时钟，格雷码变化时可能就是一个clka时钟周围变化一次，所以clka驱动的格雷码已经变化5次，clkb才采样一次，这样格雷码会有5bit可能发生变化，这样不就不是相邻态了么，不是相邻态各类码的状态变化就不是只变化了1bit，可能多比特都发生了变化，这时不就有可能采样到错误的格雷码了么？
>
> 实际上使用了maxdelay约束后，满足maxdelay约束后，是不会出现上述情况的，第一个bit发生变化后，这个比特一定会在第二个clka之前就在clkb的d端稳定下来，换句话说只有第5个bit发生变化是不确定的，前4个都稳定下来了，我们已经使用maxdelay将延时约束在clka的时钟周期之内了，所以前4bit在目的寄存器稳定下来了，如果没有用maxdelay约束，就是说每个bit不能再clka的时钟周期内稳定下来，过来好几个周期才稳定下来，这是用clkb采样就会出现错误，这就是为什么使用格雷码约束一定要将源寄存器和目的寄存器之间的延迟约束在一个时钟周期内
>
> 单比特跨时钟域只是对性能有影响，不会出现错误

