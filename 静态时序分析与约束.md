# 静态时序分析与约束

## 一. FPGA 与时序仿真的基本知识

1. 认识FPGA

   1. FPGA英文全称

      | Field | Programmable | Gate | Array |
      | ----- | ------------ | ---- | ----- |
      | 现场  | 可编程       | 门   | 阵列  |

   2. 百度词条

      ​	FPGA（Field Programmable Gate Array）是在PAL、GAL等可编程器件的基础上进一步发展的产物。它是作为专用集成电路（ASIC）领域中的一种半定制电路而出现的，既解决了定制电路的不足，又克服了原有可编程器件门电路数有限的缺点。

   3. FPGA的三要素

      ![FPGA三要素结构图]()

      1. 可编程逻辑功能块（logical element），Cell（单元 ）
         - 查找表（组合），D触发器（时序），进位链
         - 现下FPGA的组合电路是通过分析输入代码的真值表，将其映射在LUT资源中，这样做的目的是使不同门电路的时间变得可控，精确，是设计更稳定
      2. 片内互联线（interconnect），IC——内部连线
         - 连线线段和开关
      3. 输入输出块
         - 可编程输入输出完成芯片 内部逻辑与外部管脚之间的接口，围绕在逻辑单元阵列四周，可编程输入输出块的功能和性能从一定程度上也决定了该器件的市场定位
         - 输出寄存器，输入寄存器，输出使能寄存器，输入延迟链，输出延迟链，上拉电阻

   4. FPGA的扩展资源

      ![FPGA扩展资源示意图](静态时序分析与约束.assets/FPGA资源分布图.jpg)

2. 认识FPGA的时序仿真

   1. 什么是时序分析？

      - 针对当前的时序约束生成的时序报告，使用修改关键路径等方法使得设计更加的健壮，更加稳定
      - 时序分析一定是针对特定的器件的
   2. 什么是时序约束？

      - 对当前设计进行合理的时钟频率设置，使EDA软件在布局布线时更加合理的利用FPGA的资源，指导编译软件对设计进行必要的优化，以使编译结果能够满足设计需求
   3. 为什么进行时序仿真？（时序仿真的目的）

      - 在设计流程是讲到有两种手段验证设计是否达到要求，其一是功能仿真；其二是静态时序分析
      - 功能仿真验证设计功能是否完善，若不完善，修改rtl代码完善功能
      - 时序仿真验证设计是否稳定且健壮，若不稳定，进行必要的时序分析并调整时序约束

      - 比如clk要运行在125M，就创建这个时钟的约束并约束频率为125M，那么软件看到这个约束之后，就会去优化这个时钟驱动的所有寄存器相关的布局布线，使这些寄存器之间的数据传输在125M的时候依旧不出错
   4. 时序分析与时序约束的关系

      - 在静态时序分析中，时序分析与时序约束是相辅相成的
      - 有了时序约束，EDA软件才会进行合理的布局布线，并生成当前时序约束的时序报告
      - 针对当前约束的时序报告，才能更好的改进时序约束。
   5. 时序约束约束的是什么，
      - 时序分析一定是基于逻辑设计在该特定器件上经过布局布线之后的网表（该网表包含了设计中每一个逻辑具体在该器件的什么资源上实现，而且还包括该资源在器件内的具体位置，还包括信号从每个节点传输到下一个节点的具体延迟时间）
      - 时序分析不是在对代码进行分析，而是在对真是的门级传输路径进行分析
   6. 约束电路中所有的时序路径
      1. 输入到寄存器的路径
      2. 寄存器到寄存器之间的路径
      3. 寄存器到输出的路径
      4. 输入直接到输出的路径

## 二. 时序分析究竟在分析什么？

1. 我们关注的是什么

   1. 我们这个系统能跑多少兆，能跑多快，也就是系统的最高运行频率，什么叫正常工作，数据被稳定的采样

2. 从一个典型的案例开始

   1. 这个典例的目的是我们要一步一步的认识我们的代码是如何转化成电路的，在实际与理想情况到底会存在什么样的误差，这是我们进行时序分析的前戏，需要了解的基础知识

   2. 案例RTL代码

      ```verilog
      module (input clk,input a,input b,output c);
          reg a_reg， b_reg;
          wire c_wire;
          always@(posedge clk)begin 
              a_reg <= a;
          	b_reg <= b;
          end
          assign c_wire = a_reg & c_reg;
          always@(posedge clk )
              c <= c_wire ;
      endmodule 
      ```

   3. 代码生成的电路示意图

      ![案例代码示意图]()

      1. 在进行分析时我们首先设定时钟是理想的，时钟走线完全精确的，在这里我们只分析寄存器，组合逻辑，以及内部走线，也就是先假定我们要约束的东西是准确的

         ![案例时序图]()

      2. 在实际中

         1. 数据从寄存器的D端口到Q端口会存在延迟
         2. 内部走线会存在延迟
         3. 组合逻辑的门电路存在延迟

         图中未发生变化的信号没有画出，根据上述的电路示意图，考虑上面的因素，我们可以画出上面的时序图，由图可知

         1. 在当前条件下，a_reg信号并不是在时钟沿到来时立刻发生变化，而是延后了一段时间，同样可得知c_reg信号的情况
         2. 在a_reg信号发生变化时，c_wire信号也不是立即发生变化，而是延后了一段时间，这短时间包括走线的延迟以及组合逻辑门电路的延迟

3. 进一步分析实际情况（在这里忽略了时钟抖动以及一些跟实际的因素）

   1. 将实际的设计进行抽象可得电路图，包括走线，寄存器构成的时序电路，基本门构成的组合逻辑，以及时钟资源

      ![实际设计抽象电路图]()

   2. 上述电路产生了最基本的书序图如下所示

      ![基本的时序图]()

      我们可以看到在这里我们加入了时钟延迟，走线延迟，以及寄存器本身存在的延迟，在实际的时序分析中我们就是讲这样的时序组合进行分析并添加约束就是我们所说的静态时序分析

      - 在这里我们首先要说几个名词
        - $T_{skew}$ —— 时钟从输入的源端口出发，到达目的寄存器和源寄存器的时间差值
        - $T_{su}$ —— 建立时间，目的寄存器特性决定，在时钟信号上升沿到达其时钟接口时，其数据输入端（D）的数据必须提前Nns稳定下来，否则就无法保证数据正确存储。寄存器要求的，其数据端口的值必须提前于时钟上升沿达到其时钟端口的时间值，这个值感觉上是个正值，但是也不一定，altera中就有负数的情况，具体是啥原因不知道
        - $T_{co}$ —— 输出时间，时钟上升沿到达D触发器  到  数据输出到Q端的延迟
        - $T_{slack}$ —— 余量，数据要求时间与数据到达时间的差值，如果为正值，则表明数据能被目的寄存器正确接收，如果是负值，则表明数据不能被目的寄存器正确接收 
        - $T_{clk}$ —— 时钟周期
        - $T_{clk1}$ —— 时钟到达源寄存器的时间延迟
        - $T_{clk2}$ —— 时钟到达目的寄存器的时间延迟
        - $T_{data}$ —— 数据从源寄存器的Q端口到达目的寄存器的D端口的时间
      - 结合上述的名词，我们就能看懂最基本的时序分析图

   3. 在这里，我们要着重讲解$T_{slack}$是如何产生的，这是进行时序分析最基本的一个量

      1. 从上图重我们可以看出，数据要求时间与数据到达时间之间的关系，如果slack为负，就说明没有在要求的时间内到达指定的寄存器，这样目的寄存器就会把上一个数据继续寄存下来，导致数据分析的错位，从而使电路进入未知的状态
      2. ==slack = data require path - data arrivel path==
         - 即：$T_{clk1} + T_{co} + T_{data} <= T_{clk} + T_{clk2} - T_{su}$====>数据到达时间 <= 数据需求时间
         - 即：$T_{slack} =  T_{clk} + T_{clk2} - T_{su}  - T_{clk1} - T_{co} - T_{data} $
         - 即：$T_{slack} =  T_{clk} + T_{skew} - T_{su}  - T_{co} - T_{data} $
      3. 由此，我们推出计算余量的一个公式，但这又有什么用呢，答，基本没什么用，只是知道了这个大约摸的时间余量是怎么来的，跟精确的还有时钟抖动，EDA软件的分析算法等

4. 再进一步分析分析两个值

   1. Clock Pessimism 
      - 在EDA软件分析 $T_{clk2}$ 的时候，会认为时钟从源端口到目的寄存器是按照最快的路径走的，也就是 $T_{clk2}$ 在计算时会偏小
      - 而在分析 $T_{clk1}$ 的时候，会认为时钟从源端口到源寄存器是按照最慢路径走的，也就是 $T_{clk2}$ 在计算时会偏大
      - 显然时钟从时钟引脚输入到源寄存器和目的寄存器时会走一段共同的路，这段走线的时间不可能在计算 $T_{clk2}$ 时快，在计算 $T_{clk1}$ 时慢
      - 所以这是过小的估计了时钟偏斜，过于悲观的估计了时间余量，这在我们上面的时序同种可以清楚的看出
      - 所以EDA软件在进行slack计算的时候，会将这个过补偿掉这个过于悲观的值
   2. Clock Uncertainly
      - 首先我们知道，时钟的上升沿不是准确的，这是由与晶振原因造成，不可避免的，并且存在一些频率，是不可能被将时钟的占空比精准的控制在50%的所以这就会在成一个时钟跳动不精准的问题
      - 在实际中确实会存在一些小抖动，并且在计算精准的slack时需要将时钟抖动的这个因素考虑在内
      - 但是这个抖动是向左抖还是向右抖失误法被确定的（也就是时钟沿提前到来还是延后一点到来是不缺定的），EDA软件在分析时回估计出这个不确定的值，并将它减掉

5. 致次我们对于整个电路中最基本的时序分析完成，这只是辅助我们了解了这个时序分析的一写基本的只是，此时我们只能算是看得EDA软件分析的基本逻辑

## 三. 时序分析软件中是怎么完成的？（Quartus II）

1. 软件中为设计添加约束作用与方法

   1. 作用
      1. 知道编译软件进行必要的优化，以使编译结果满足设计需求
      2. 在电路综合的过程中，所有时序电路以及组合电路的优化都是以时钟为基准来计算路径延迟的，因此，一般都要在综合的时候指定时钟，作为估计路径延迟的基准，给时序分析工具提供一个分析时序的参考
      3. 这是因为EDA软件在进行布局布线时会以时序约束的时钟频率为指标，在完成布局布线时会自动的向这个目标看齐，如果不能达到，那么会出现slack为负的情况，如果时序约束合理，那么slack为正，在看齐目标时，Fmax表示在当前的设计（网表文件）中，该设计运行的最高频率，所以约束不同，布局布线的情况不同，Fmax也就不同。
   2. 有两种方法
      1. 通过直接编辑 sdc 文件进行约束
         - 没有sdc文件时软件自动分析时序约束（如果某个被认为是时钟的信号没相关的频率周期的定义，软件就会自动将其按照1000MHz的频率来进行分析）
         - 有sdc文件约束时以sdc文件为准（如果工程没有添加任何约束文件，或者约束文件中没有任何有效的内容，软件会自动分析并加入软件自动分析出来的时钟信号并加入合理的约束）
      2. 通过软件的可视化界面进行操作生成sdc文件
   3. 总之都是要生成sdc文件，这个sdc 文件是一种基于tcl语言的命令脚本，通过使用tcl命令的逻辑来完成约束，一个工程中如果添加了多个sdc文件且同时生效的话，软件会一次按照这两个文件中的内容进行约束和报告，如果对某一个节点在多个约束文件中都添加了约束信息，则后执行的约束内容会覆盖掉先执行的约束内容

2. Quartus 中进行时序分析所使用的名词
   - slack，只有当slack大于0的情况下数据才能稳定的被正确采样

   - Fmax，$Fmax= 1/(T_{clk} - slack)$，这个值是针对特定的时钟域的最大运行频率，在有一个clk驱动的所有寄存器中，最坏路径能够运行的最高时钟频率

   - From node，源寄存器的节点名，先变化的节点

   - To node，目的寄存器的节点名，跟随变化的节点

   - Relationship，lunch clock edge与latch clock edge的时间差，当两个时钟他们之间是同源同相位的时钟，他们之间的关系是1个周期，当目的寄存器与源寄存器的时钟是同一个时钟但是时钟的相位有所不同时，他们之间的关系就不是1个周期，我感觉就是一个时钟从pll出来两个相位不同时钟信号，他们之间的关系是源寄存器时钟的上升沿到目的寄存器的第一个时钟上升沿之间的时间，如下图

     ![relation与时钟的关系]()

   - Latch clock，目的寄存器接收数据的时钟

   - Lunch clock，源寄存器发射数据的时钟

   - Data delay， $data delay = T_{data} + T_{co}$

3. 时序报告的一些要点

   ![操作截图]()

   \>slow 1200mV 85C model

   ​	\> FMAX Summary

   ​		\> 选中一条标红路径，然后右击，点击 report timing，或者locate到源代码文件中，或RTL电路图中

   ​	\> warst-case Timing Paths

   ​		\>  分析建立时间余量的时候，主要观察85C慢速模型下的报告

   \>slow 1200mV 0 C model

   \>fast   1200mV 0 C model

   ​	\> FMAX Summary

   ​		\> 选中一条标红路径，然后右击，点击 report timing，或者locate到源代码文件中，或RTL电路图中

   ​	\> warst-case Timing Paths

   ​		\>  分析保持时间余量的时候，主要观察0C快速模型下的报告

4. 在TTA软件中的分析过程

   1. 打开TTA软件
   2. 创建一个网表 create Timing Netlist
   3. 读取sdc文件 
   4. 查看报告，加入约束
      1. constraints---->create clock（创建时钟约束）
      2. 创建名字，周期，以及占空比（默认50%）
   5. 在TTA中每执行一个操作之后，都需要特别留意console窗口中的报告，要观察操作是否生效
   6. 所有约束操作完成后需要执行写sdc文件的操作，这个文件会生成包含所有约束的sdc文件

5. 创建时钟约束的两个操作方法

   - Assignment下的TimeQuest Timing Analyzer Wizard

     ![操作截图]()

   - TTA 软件下的constraints下的 create colcks

     ![操作截图]()

   - clk name创建一个新的时钟也就是给时钟一个代号
   - clk pin指定其在文件中的引脚
   - period周期
   - rising上升沿的时间
   - falling下降沿的时间

6. 对使标红的路径进行修改（修时序）

   - 在关键路径中插入寄存器来优化逻辑

## 四. 本文所用到的一些Tips

- setup time，hold time，如下图

  ![setup time，hold time]()

- D触发器D端口的数据必须必时钟上升沿到达的时间提前Nns到达D触发器的端口

- 时钟类型，base基础时钟 ，generate生成时钟

- 全局时钟树，使用专门的时钟管脚输入时钟可以被自动的映射到时钟树上，使用普通管脚输入时钟必须使用全局时钟约束通知软件将时钟约束上去

- 使用assignments下的TimeQuest Timing Analyzer wizard创建时钟约束（创建时信号名不必与管脚名相同）

- 在代码中的#1是在模拟真实寄存器从时钟上升沿到达其时钟管脚后数据要经过一定时间才能发生变化，不被综合

- TTA下的clocks的报告说的是当前工程中各个时钟信号的属性

- 一旦工程中加入有效的sdc文件中软件就一切以sdc文件中的约束为准，不再自动分析和加入其它信号的约束

- 如果没有错误路径，但是我们仍然想查看这条路径的时序信息，此时可以手动报告路径，TTA软件下 custom reports，reporting timing 设置观察路径的起始寄存器与目的寄存器然后就可以查看





​	